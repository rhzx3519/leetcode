/**
@author ZhengHao Lou
Date    2022/02/09
*/
package main

import (
	"fmt"
)

/**
https://leetcode-cn.com/problems/minimize-malware-spread-ii/
思路：dfs
通过dfs统计未传染节点所联通的传染节点数量，如果未传染节点只联通了一个传染节点，
则删除传染节点，这个未传染节点就不会被传染 ，统计处于这种情况最多的传染节点
*/
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	infectedBy := make([][]int, n)
	clean := make([]int, n)
	for _, u := range initial {
		clean[u] = 1
	}

	for _, u := range initial {
		vis := map[int]bool{u: true}
		dfs(u, vis, graph, clean)
		for v := range vis {
			infectedBy[v] = append(infectedBy[v], u)
		}
	}

	unclean := make(map[int]int)
	for i := 0; i < n; i++ {
		if len(infectedBy[i]) == 1 {
			unclean[infectedBy[i][0]]++
		}
	}

	var best, node int
	for _, u := range initial {
		if unclean[u] > best || (unclean[u] == best && u < node) {
			best = unclean[u]
			node = u
		}
	}

	fmt.Println(unclean)
	fmt.Println(node)
	return node
}

func dfs(u int, vis map[int]bool, graph [][]int, clean []int) {
	for v := range graph[u] {
		if graph[u][v] == 1 && clean[v] == 0 && !vis[v] {
			vis[v] = true
			dfs(v, vis, graph, clean)
		}
	}
}

func main() {
	//minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1})
	//minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 1}, {0, 1, 1}}, []int{0, 1})
	//minMalwareSpread([][]int{{1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}}, []int{0, 1})
	minMalwareSpread([][]int{{1, 0, 0, 0, 0, 1, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0},
		{0, 0, 0, 0, 1, 0, 0}, {1, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, 1}}, []int{4})
}
